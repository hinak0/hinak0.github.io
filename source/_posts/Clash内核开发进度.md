---
title: Clash内核开发进度
categories:
  - 通信網
date: 2023-12-30 16:00:04
tags:
cover:
---

这个周基本没干别的，全在clash的定制化上花时间了，下面总结一下进度。

## ClashConfigConverter

一个轻量化的基于 Golang 的 Clash 订阅链接转换器。支持以下功能：

- 精确到单个订阅链接的 udp 控制与请求头自定义
- 读取自定义的本地规则列表
- 预加载节点
- 正则排除节点

目前只能算一个半成品，没有做太多测试，也没有写readme，项目已经开源：

https://github.com/hinak0/ClashConfigConverter

有时间打磨一下。

## Clash

对开源clash内核的二次开发。

开发遵循以下几个原则：

- 兼容现有的配置文件格式
- 沿袭现有的项目结构，只做加减法。
- 代码可读性与性能同样重要

clash采用总线模式组织代码，各个模块相对独立，总线也就是hub模块。

1. 总线负责解析配置文件，触发全局热更新
2. 总线向各个子模块传递参数，一般只包括基本类型，constant类型，以及配置文件。
3. 各个子模块之间不相互引用，需要的数据类型定义在constant模块里。

### 远端解析功能

之前就发现clash所有的dns解析都是直接解析，如果配置了境外的dns，解析速度就要打折扣，更多时候境外dns根本不通，必须等到5秒超时时间。（尤其是配置了fallback,而且fallback全是境外dns的时候）。

于是开发一个dns自定义传输层（也就是远端解析）的功能，就军训上面的原则，开发有以下几个步骤：

1. 不能直接引用tunnel中的函数（模块之间要相互独立），而是由总线传入一个ConnContext的通道，传输层使用这个通道
2. 需要的ConnContext由总线传入dns模块。
3. 在inbound模块新建一个newINVODKE方法，用于创建invoke的net.conn对象
4. 最后将创建好的net.conn用在需要的传输层自定义方法。

相对于之前的直接走本机监听地址，有以下几点优点：

1. 使用net.Pipe()，在内存中进行数据交换，减少了系统调用，优化了性能。
2. 避免了硬编码，或者跨层读取配置文件来获得代理地址。
3. 新增的invoke调用或许可以用于后面的其他模块。

这个功能目前运行良好，体感上响应速度快了不少，但是存在以下几个问题。

1. outbound的dns解析也要依赖resolver来进行，但是resolver解析需要outbound就循环了。[解决办法是至少配置一个境内dns，直接命中direct]

### 优化日志表现

考虑到clash本身有完善的控制面板api，本着"没有日志就是运行正常"的理念，去除了大部分无用的正常日志输出，加强了各种错误日志输出，更有利于掌握运行状态。
